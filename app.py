# -*- coding: utf-8 -*-
"""BTP1.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LoMiUFQHaS-8woN6PGFU3BqgPcMGw0Aj
"""

#The libraries that have to be included to implement the method
import numpy as np
import cv2
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import math
import time
from scipy import interpolate
import io
import streamlit as st
def plotGenerator():
    st.title("Reinforced Concrete Column Interaction Diagram Generator")
    start = time.time()
    st.success("Welcome User")

    t = st.selectbox(
        "Select the type of cross-section:",
        options=[0, 1, 2, 3, 4],
        format_func=lambda x: ["Circle", "Rectangle", "I-section", "T-section", "Arbitrary"][x],
        index=0
    )
    if t == 1:
        # The following inputs are asked if the user chooses rectangle
        # Requesting the user to enter the no. of reinforcement layers
        N = []
        n = st.number_input("Enter number of layers of reinforcement(>=2) : ", min_value=2, step=1)
        
        # Requesting the user to enter the no. of bars in each layer
        for i in range(1, n+1):
            bars = st.number_input(f'enter the no.of bars in reinforcement layer {i} (>=2) :', min_value=2, step=1)
            N.append(bars)

        iden = st.radio("Are the diameters of the bars identical?", ('Y', 'N'))
        ll = max(N)
        dia0 = np.zeros([n, ll])
        dia = np.zeros([n, ll])
        
        if iden == 'N':
            for i in range(n):
                z = i+1
                if i == 0:
                    input_str = st.text_input(f"Enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                    dia0[i, 0:N[i]] = list(map(int, input_str.split()))
                    while any(dia0[i, j] < 12 for j in range(N[i])):
                        st.warning("All diameters must be ≥ 12mm")
                        input_str = st.text_input(f"Re-enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                        dia0[i, 0:N[i]] = list(map(int, input_str.split()))
                elif i > 0 and i < n-1:
                    input_str = st.text_input(f"Enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                    dia0[i, 0], dia0[i, 1] = map(int, input_str.split())
                    while dia0[i, 0] < 12 or dia0[i, 1] < 12:
                        st.warning("All diameters must be ≥ 12mm")
                        input_str = st.text_input(f"Re-enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                        dia0[i, 0], dia0[i, 1] = map(int, input_str.split())
                elif i == n-1:
                    input_str = st.text_input(f"Enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                    dia0[i, 0:N[i]] = list(map(int, input_str.split()))
                    while any(dia0[i, j] < 12 for j in range(N[i])):
                        st.warning("All diameters must be ≥ 12mm")
                        input_str = st.text_input(f"Re-enter dia of bars in layer {z} (space separated, diameter ≥ 12mm) :")
                        dia0[i, 0:N[i]] = list(map(int, input_str.split()))

            dia = 2 * dia0
        else:
            # Requesting the user to specify the diameter of reinforcement in each layer
            diameter = st.number_input('enter the diameter reinforcement in mm(>=12) : ', min_value=12, step=1)
            for i in range(len(N)):
                for j in range(N[i]):
                    dia[i, j] = int(2 * diameter)
        
        # width of the column
        b0 = st.number_input("Enter the width of column in mm (>=225): ", min_value=225, step=1)
        b = b0 * 2
        
        # length of the column
        l0 = st.number_input("Enter the length of the column in mm(>=300) : ", min_value=300, step=1)
        l = 2 * l0
        
        # The grade of the steel
        grade = st.selectbox('enter the grade of steel : ', [250, 415, 500])
        
        # The grade of the concrete
        Fck = st.number_input('enter the grade of concrete :', min_value=0.1, step=0.1)
        
        # The clear cover for the cross section
        cc0 = st.number_input('enter the effective cover of column in mm : ', min_value=6.0, step=1.0)
        cc = 2 * cc0

        # defining the parameters that are included
        areas = []
        n = len(N)
        ratio = []
        comp_len = []
        strain = []
        stress_s = []
        stress_c = []
        force = np.zeros([21])
        moment = np.zeros([21])
        mom_c = np.zeros([l])
        mom_s = np.zeros([l])
        force_c = np.zeros([l])
        force_s = np.zeros([l])
        x = int(b)
        y = int(l)

        # Creating an empty dark image
        img = np.zeros((l+200, b+200, 3), dtype="uint8")

        # Drawing the whole cross section based on user inputs
        cv2.rectangle(img, (int(100), int(100)), (int(b+100), int(100+l)), (0, 255, 0), -1)

        x1 = (100+cc)
        y1 = (100+cc)
        c1_list = [[x1, y1]]
        vs = ((l-2*cc)/(n-1))
        for i in range(len(N)):
            y1 = y1 + vs
            c1_list.append([x1, y1])
        for i in range(len(N)):
            hs = ((b-2*cc)/(N[i]-1))
            [x3, y3] = c1_list[i]
            for j in (range(N[i])):
                cv2.circle(img, (int(x3), int(y3)), int(dia[i, j]/2), (255, 0, 0), -1)
                x3 = x3 + hs

        # the image is resized
        dim = (int(b/2+100), int(l/2+100))
        resized = cv2.resize(img, dim, interpolation=cv2.INTER_AREA)

        # Show the image using Streamlit
        st.image(resized, caption='Column Cross Section', use_column_width=True)

        # Analysis of the cross section begins
        # the area of steel and concrete from each layer is calculated
        areac = []
        areas = []
        for i in range(100, 100+l):
            c = 0
            s = 0
            for j in range(100, 100+b):
                if img[i][j][0] == 0 and img[i][j][1] == 255 and img[i][j][2] == 0:
                    c = c+1
                else:
                    s = s+1
            areac.append(c)
            areas.append(s)

        # the reinforcement ratio is calculated
        pt = (math.fsum(areas)/(math.fsum(areas)+math.fsum(areac)))*100

        # centroidal axis for the cross-section
        c_a = 0
        temp = 0
        for i in range(l):
            temp = (areac[i]*0.447*Fck+areas[i]*0.869*grade)*(i+1)
            c_a = c_a + temp
        C = (c_a)/(math.fsum(areas)*0.869*grade+math.fsum(areac)*0.447*Fck)

        # the each ratio is referred to different position of neutral axis
        ratio = [10.0, 5.0, 2.5, 2.0, 1.5, 1.4, 1.3, 1.2, 1.1, 1.05, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]

        # analysing the section for each position of neutral axis
        for o in range(20):
            strain = np.zeros([l])
            stress_s = []
            stress_c = []
            if o < 11:
                for i in range(l):
                    strain[i] = abs((-0.002/(ratio[o]*l-(3/7)*l))*(i-ratio[o]*l))
            else:
                for i in range(l):
                    strain[i] = abs((-0.0035/(ratio[o]*l))*(i-ratio[o]*l))

            # generating stress strain profiles for different grades of steel
            if grade == 415:
                ydata = np.array([0, 288.7, 306.7, 324.8, 342.8, 351.8, 360.9, 360.9, 360.9, 360.9])
                xdata = np.array([0, 0.00144, 0.00163, 0.00192, 0.00241, 0.00276, 0.00380, 0.008, 0.02, 0.0320])
            elif grade == 500:
                ydata = np.array([0, 347.8, 369.6, 391.3, 413.0, 423.9, 434.8, 434.8, 434.8])
                xdata = np.array([0, 0.00174, 0.00195, 0.00226, 0.00277, 0.00312, 0.00417, 0.005, 0.04])
            elif grade == 250:
                ydata = np.array([0, 217.5, 217.5, 217.5])
                xdata = np.array([0, 0.001084, 0.005, 0.04])
            f_s = interp1d(xdata, ydata, kind='linear')
            for i in range(l):
                temp = f_s(strain[i])
                stress_s.append(temp)

            # generating the concrete stress strain curve
            n = 0.00
            fck = np.zeros([30])
            N = np.zeros([30])
            for i in range(21):
                fck[i] = 0.447*Fck*(((2*n)/0.002)-(n/0.002)**2)
                N[i] = n
                n = n + 0.0001
            for i in range(21, 30):
                fck[i] = 0.447*Fck
                N[i] = n
                n = n + 0.015
            f_c = interp1d(N, fck, kind='cubic')

            # extracting stress from the stress strain profile of concrete
            for i in range(l):
                temp = f_c(strain[i])
                stress_c.append(temp)

            # calculating the total force acting on the cross section
            for i in range(l):
                if i < ratio[o]*l:
                    force_c[i] = stress_c[i]*areac[i]
                    force_s[i] = stress_s[i]*areas[i]
                else:
                    force_c[i] = 0
                    force_s[i] = -stress_s[i]*areas[i]
            force[o] = (math.fsum(force_c) + math.fsum(force_s))

            # calculating the total moment acting on the cross section
            for i in range(l):
                mom_c[i] = force_c[i]*(int(C)-i)
                mom_s[i] = force_s[i]*(int(C)-i)
            moment[o] = math.fsum(mom_c)+math.fsum(mom_s)

        # pure compression point and point with minimum eccentricity
        force[20] = int((0.447*Fck*math.fsum(areac) + f_s(0.002)*math.fsum(areas)))
        moment[20] = 0
        force_emin = int(0.9*(0.447*Fck*math.fsum(areac) + f_s(0.002)*math.fsum(areas)))
        emin = 0.05*l
        moment_emin = force_emin*emin*2

        # normalized forces and moments
        force = force/(Fck*b*l)
        moment = moment/(Fck*b*l**2)
        force_emin = force_emin/(Fck*b*l)
        moment_emin = moment_emin/(Fck*b*l**2)

        # sorting them for plotting purpose
        sorted_force = np.sort(force)
        org_moment = np.zeros(21)
        for i in range(21):
            k = np.where(force == sorted_force[i])
            org_moment[i] = moment[k[0][0]]

        # interpolating to generate the curve
        int_cur = interpolate.InterpolatedUnivariateSpline(sorted_force, np.array(org_moment))

        # test cases from the SP 16(standard curves)
        # (Test cases omitted for brevity, but can be included similarly)

        # line for minimum eccentricity
        y_values = [force_emin, force_emin]
        x_values = [0, int_cur(force_emin)]

        # plotting our current interaction curve
        fig, ax = plt.subplots(dpi=1200)
        ax.plot(int_cur(sorted_force), sorted_force, label='program based')
        ax.plot(x_values, y_values, 'g--', label='min. ecc. loading')
        ax.set_xlim(0)
        ax.set_ylim(0)
        ax.set_title('interaction diagram')
        ax.set_xlabel('$M_u/(f_{ck}.b.D^2)$')
        ax.set_ylabel('$P_u/(f_{ck}.b.D)$')
        ax.grid(visible=True, color='r', which='major', linestyle='-', linewidth=0.4)
        ax.grid(visible=True, which='minor', color='r', linestyle='-', alpha=0.15)
        ax.minorticks_on()
        ax.legend(loc='upper right', fontsize='x-small')
        st.pyplot(fig)
        #Download
        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        st.download_button(
            label="Download plot as PNG",
            data=buf,
            file_name="Interaction_plot.png",
            mime="image/png"
        )
        # check points function
        def check_points():
            check_points = st.radio('do you want to have some check points?', ('Y', 'N'))
            if check_points == 'Y':
                P = list(map(float, st.text_input("Enter the Normalized force values (space separated):").split()))
                M = list(map(float, st.text_input("Enter the Normalized moment values (space separated):").split()))
                
                fig, ax = plt.subplots(dpi=1200)
                ax.plot(int_cur(sorted_force), sorted_force, label='program based')
                ax.plot(x_values, y_values, 'g--', label='min. ecc. loading')
                ax.plot(M, P, 'bo', label='checks points')
                for i in range(len(P)):
                    ax.text(M[i], P[i], i+1, fontsize=12)
                ax.grid(visible=True, color='r', which='major', ls='-', lw=0.4)
                ax.grid(visible=True, which='minor', color='r', linestyle='-', alpha=0.15)
                ax.minorticks_on()
                ax.set_title('Safety check points')
                ax.set_xlim(0)
                ax.set_ylim(0)
                ax.legend(loc='upper right', fontsize='x-small')
                ax.set_xlabel('$M_u/(f_{ck}.b.D^2)$')
                ax.set_ylabel('$P_u/(f_{ck}.b.D)$')
                st.pyplot(fig)

        check_points()

        end = time.time()
        st.write(f"Runtime of the program is {end - start}")


    if t == 0:
        #The following inputs are asked if the user chooses circle
        #Requesting the user to enter the no. of bars
        n = st.number_input('enter the no.of bars of reinforcement : ', min_value=6, step=1, value=6)
        #the diameter of each bar
        dia0 = st.number_input('enter the diameter reinforcement : ', min_value=12, step=1, value=12)
        dia = 2*dia0
        #the clear cover of reinforcement
        cc0 = st.number_input('enter the effective cover of coulum in mm : ', min_value=0.0, value=40.0)
        cc = 2*cc0
        #the diameter of the column
        min_d = int(2.732*dia+cc*2)
        d0 = st.number_input('enter the diameter of coulum in mm : ', min_value=min_d+1, step=1, value=min_d+1)
        d = 2*d0
        #the grade of steel
        grade = st.selectbox('enter the grade of steel : ', [250,415,500])
        #the grade of concrete
        Fck = st.number_input('enter the grade of concrete :', min_value=0.1, value=20.0)


        #defining the parameters that are included
        angle = 2*math.pi/n
        r = (d-2*cc)/2
        x = int(d)
        y = int(d)
        ratio = []
        comp_len= []
        strain = []
        stress_s=[]
        stress_c=[]
        force = np.zeros([22])
        moment = np.zeros([22])
        mom_c = np.zeros([d])
        mom_s = np.zeros([d])
        force_c = np.zeros([d])
        force_s = np.zeros([d])


        #Creating an empty dark image
        img = np.zeros((d+200,d+200, 3), dtype = "uint8")


        #Drawing the whole cross section based on user inputs
        cv2.circle(img, (int(d/2)+100,int(d/2)+100), int(d/2), (0, 255, 0), -1)
        for i in range(n):
            cv2.circle(img, (int(int(d/2)+100+r*math.cos((i+1)*angle)),int(int(d/2)+100+r*math.sin((i+1)*angle))), int(dia/2), (255, 0, 0), -1)


        #the image is resized
        dim = (int(d/2+100),int(d/2+100))
        resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)
        st.image(resized, caption='Column Cross Section')

        #Analysis of the cross section begins
        #the area of steel and concrete from each layer is calculated
        areac=[]
        areas=[]
        for i in range(100,100+d):
            c = 0
            s = 0
            for j in range(100,100+d):
                if img[i][j][0] == [0] and img[i][j][1] == [255] and img[i][j][2] == [0]:
                    c = c+1
                elif img[i][j][0] == [255] and img[i][j][1] == [0] and img[i][j][2] == [0]:
                    s = s+1
            areac.append(c)
            areas.append(s)
        cv2.circle(img, (int(x),int(y)), int(d/2)+4, (255, 255, 255), 4)

        #calculating the reinforcement ratio
        pt = math.fsum(areas)/(math.fsum(areas)+math.fsum(areac))


        #centroidal axis for the cross-section
        c_a = 0
        temp = 0
        for i in range(d):
            temp = (areac[i]*0.447*Fck+areas[i]*0.869*grade)*(i+1)
            c_a = c_a + temp
        C = (c_a)/(math.fsum(areas)*0.869*grade+math.fsum(areac)*0.447*Fck)


        #the each ratio is reffered to different position of neutral axis
        ratio = [40.0,20.0,5.0,2.0,1.5,1.4,1.3,1.2,1.1,1.05,1.0,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1]

        #analysing the section for each position of neutral axis
        for o in range(20):
            strain = np.zeros([d])
            stress_s=[]
            stress_c=[]
            if o < 11:
                for i in range(d):
                    strain[i]= abs((-0.002/(ratio[o]*d-(3/7)*d))*(i-ratio[o]*d))
            else:
                for i in range(d):
                    strain[i]= abs((-0.0035/(ratio[o]*d))*(i-ratio[o]*d))


        #generating stress strain profiles for different grades of steel
            if grade == 415:
                ydata = np.array([0,288.7,306.7,324.8,342.8,351.8,360.9,360.9,360.9,360.9])
                xdata = np.array([0,0.00144,0.00163,0.00192,0.00241,0.00276,0.00380,0.008,0.02,0.0320])
            elif grade == 500:
                ydata = np.array([0,347.8,369.6,391.3,413.0,423.9,434.8,434.8,434.8])
                xdata = np.array([0,0.00174,0.00195,0.00226,0.00277,0.00312,0.00417,0.005,0.04])
            elif grade == 250:
                ydata = np.array([0,217.5,217.5,217.5])
                xdata = np.array([0,0.001084,0.005,0.04])
            f_s = interp1d(xdata, ydata, kind='linear')
            for i in range(d):
                temp = f_s(strain[i])
                stress_s.append(temp)


        #generating the concrete stress strain curve
            n=0.00
            fck= np.zeros([30])
            N = np.zeros([30])
            for i in range(21) :
                fck[i] = 0.447*Fck*(((2*n)/0.002)-(n/0.002)**2)
                N[i] = n
                n = n + 0.0001
            for i in range(21,30):
                fck[i]= 0.447*Fck
                N[i] = n
                n=n + 0.015
            f_c = interp1d(N,fck, kind='cubic')

            #extracting stress from the stress strain profile of concrete
            for i in range(d):
                temp = f_c(strain[i])
                stress_c.append(temp)


            #calculating the total force acting on the cross section(+ve for compression and -ve for tension)
            for i in range (d):
                if i < ratio[o]*d:
                    force_c[i] = stress_c[i]*areac[i]
                    force_s[i] = stress_s[i]*areas[i]
                else:
                    force_c[i] = 0
                    force_s[i] = -stress_s[i]*areas[i]
            force[o] = (math.fsum(force_c) + math.fsum(force_s))

            #calculating the total moment acting on the cross section(+ve for anti-clockwise and -ve for clockwise)
            for i in range (d):
                mom_c[i] = force_c[i]*(int(C)-i)
                mom_s[i] = force_s[i]*(int(C)-i)
            moment[o] = math.fsum(mom_c)+math.fsum(mom_s)

        #pure compression point and point with minimum eccentricity
        force[20] = int((0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        moment[20] = 0
        force[21] = int(0.9*(0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        emin = max(0.05*d,20)
        moment[21] = force[21]*emin


    #Normalized forces and moments
        force = force/(Fck*d**2)
        moment = moment/(Fck*d**3)


    #sorting them for plotting purpose
        sorted_force=np.sort(force[0:21])
        org_moment=np.zeros(21)
        for i in range(21):
            k=np.where(force==sorted_force[i])
            org_moment[i]=moment[k[0][0]]


    #test cases from the SP 16(standard curves)
        """Test1,n=20,Dia=30,d'=100,D=1000,fs = 500,fck= 22.5"""
        M7=np.array([0,0.03,0.057,0.06,0.071,0.075,0.089,0.0905,0.082])
        P7=np.array([0.58,0.5,0.4,0.38,0.32,0.3,0.2,0.1,0])
        """Test2,n=10,Dia=26,d'=40,D=400,fs = 250,fck= 35.2"""
        M1= np.array([0,0.015,0.04,0.06,0.069,0.076,0.081,0.0835,0.083,0.081,0.069])
        P1=np.array([0.543,0.5,0.42,0.34,0.3,0.26,0.22,0.2,0.16,0.1,0])
        """Test3,n=14,Dia=25,d'=60,D=400,fs = 250,fck= 27.34"""
        M2=np.array([0,0.023,0.04,0.052,0.066,0.075,0.087,0.1,0.105,0.103,0.102,0.098])
        P2=np.array([0.675,0.6,0.54,0.5,0.44,0.4,0.34,0.24,0.18,0.1,0.06,0])
        """Test4,n=14,Dia=16,d'=20,D=400,fs = 250,fck= 22.4"""
        M3=np.array([0,0.03,0.044,0.055,0.06,0.07,0.08,0.0805,0.08,0.078,0.075,0.064])
        P3=np.array([0.51,0.42,0.38,0.34,0.32,0.28,0.2,0.16,0.14,0.1,0.06,0])
        """Test5,n=6,Dia=30,d'=25,D=500,fs = 415,fck= 21.6"""
        M4=np.array([0,0.038,0.05,0.066,0.07,0.087,0.1,0.103,0.1,0.096])
        P4=np.array([0.598,0.5,0.46,0.4,0.38,0.3,0.2,0.1,0.04,0])
        """Test6,n=20,Dia=30,d'=100,D=1000,fs = 415,fck= 22.5"""
        M5=np.array([0,0.02,0.04,0.049,0.06,0.068,0.08,0.085,0.084,0.074])
        P5=np.array([0.546,0.5,0.44,0.4,0.34,0.3,0.2,0.14,0.1,0])
        """Test7,n=14,Dia=16,d'=20,D=400,fs = 500,fck= 22.4"""
        M6=np.array([0,0.019,0.054,0.078,0.09,0.097,0.1,0.112,0.119,0.118,0.11])
        P6=np.array([0.623,0.6,0.5,0.4,0.34,0.3,0.28,0.2,0.12,0.1,0])

        #interpolating to generate the curve
        int_cur = interp1d(sorted_force,np.array(org_moment), kind='cubic')


        y_values = [force[21],force[21]]
        x_values = [0,int_cur(force[21])]

        #plotting our current interaction curve
        fig, ax = plt.subplots(dpi=1200)
        ax.plot(int_cur(sorted_force),sorted_force, label = ' program based')
        ax.plot(x_values,y_values,'g--', label = 'min. ecc. loading')

        #plotting a test case(M1,P1 to M7,P7) for validation
        #ax.plot(M7,P7,'ro', label = 'SP16')
        ax.set_xlim(0)
        ax.set_ylim(0)
        ax.set_title('interaction diagram for circular cross-section')
        ax.set_xlabel('$M_u/(f_{ck}.D^3)$')
        ax.set_ylabel('$P_u/(f_{ck}.D^2)$')
        ax.grid(visible = True, color='r',which='major', ls = '-', lw = 0.4)
        ax.grid(visible =True, which='minor', color='r', linestyle='-', alpha=0.15)
        ax.minorticks_on()
        ax.legend(loc = 'upper right',fontsize = 'x-small')
        st.pyplot(fig)
                #Download
        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        st.download_button(
            label="Download plot as PNG",
            data=buf,
            file_name="Interaction_plot.png",
            mime="image/png"
        )


        #check points : whether if the user wants to test any test points whether they are safe or unsafe
        def Check_points():
            check_points= st.radio('do you want to have some check points?', ['Yes', 'No'])
            if check_points == 'Yes':
                P = st.text_input("Enter the Normalized force values with space :")
                P = list(map(float, P.split()))
                M = st.text_input("Enter the Normalized moment values with space : ")
                M = list(map(float, M.split()))
                
                fig2, ax2 = plt.subplots(dpi=1200)
                ax2.plot(int_cur(sorted_force),sorted_force, label = ' program based')
                ax2.plot(x_values,y_values,'g--', label = 'min. ecc. loading')
                ax2.plot(M, P, 'bo',label = 'checks points')
                for i in range(len(P)):
                   ax2.text(M[i] , P[i]  , i+1, fontsize=12)
                ax2.grid(visible=True, color='r', which='major',  ls ='-', lw=0.4)
                ax2.grid(visible=True, which='minor', color='r', linestyle='-', alpha=0.15)
                ax2.minorticks_on()
                ax2.set_title('Safety check points')
                ax2.set_xlim(0)
                ax2.set_ylim(0)
                ax2.legend(loc = 'upper right',fontsize = 'x-small')
                ax2.set_xlabel('$M_u/(f_{ck}.D^3)$')
                ax2.set_ylabel('$P_u/(f_{ck}.D^2)$')
                st.pyplot(fig2)
        Check_points()
        end = time.time()
        st.write(f"Runtime of the program is {end - start}")

    if t == 2 or t == 3:
        #dimensions of the cross-section
        b0 = st.number_input("Enter the breadth of section(mm) : ", min_value=1, step=1, value=300)
        b = b0*2
        l0 = st.number_input("Enter the length of the section(mm) (perpendicular to axis of bending) : ", min_value=1, step=1, value=500)
        l = 2*l0
        cc0 = st.number_input("Enter the effective cover for section(mm) : ", min_value=0, step=1, value=40)
        cc = 2*cc0

        #grade of the steel reinforcements
        grade = st.selectbox('enter the grade of steel : ', [250,415,500])
        #The grade of the concrete
        Fck = st.number_input('enter the grade of concrete :', min_value=0.1, value=20.0)

        if t == 2:
            #Since the vertices of I-section are 12
            v = 12

            #layout of the cross_section
            fb0 = st.number_input("Enter the width of bottom flange(mm) : ", min_value=1, step=1, value=100)
            fb = fb0*2
            ft0 = st.number_input("Enter the width of top flange(mm) : ", min_value=1, step=1, value=100)
            ft = ft0*2
            wl0 = st.number_input("Enter the width of web (mm) : ", min_value=1, step=1, value=50)
            wl = 2*wl0

            #generation the image of the cross-section
            img = np.zeros((l+200, b+200, 3), dtype = "uint8")
            for i in range(ft):
                for j in range(b):
                    img[100+i][100+j][1] = 255
            for i in range(ft,l-fb):
                k = int((b-wl)/2)
                z = int((b+wl)/2)
                for j in range(k,z):
                    img[100+i][100+j][1]=255
            for i in range (l-fb,l):
                for j in range(b):
                    img[100+i][100+j][1] = 255

        if t == 3:
            #Since the vertices of I-section are 12
            v = 8

            #layout of the cross_section
            ft0 = st.number_input("Enter the width of flange(mm) : ", min_value=1, step=1, value=100)
            ft = ft0*2
            wl0 = st.number_input("Enter the width of web (mm) : ", min_value=1, step=1, value=50)
            wl = 2*wl0

            #generation the image of the cross-section
            img = np.zeros((l+200, b+200, 3), dtype = "uint8")
            for i in range(ft):
                for j in range(b):
                    img[100+i][100+j][1] = 255
            for i in range(ft,l):
                k = int((b-wl)/2)
                z = int((b+wl)/2)
                for j in range(k,z):
                    img[100+i][100+j][1] = 255

        # coordinates of the reinforcement bars
        x_d = st.text_input("Enter the X-coordinates of all reinforcement bars with space :")
        x_d = list(map(int, x_d.split()))
        y_d = st.text_input("Enter the Y-coordinates of all reinforcement bars with space(same order as above) : ")
        y_d = list(map(int, y_d.split()))
        dia = np.zeros([len(x_d)])
        pro = st.radio("are dia are equal:", ["Y", "N"])
        if pro == "Y":
            bard = st.number_input("dia of bars:", min_value=1, step=1, value=12)
            for i in range(len(x_d)):
                dia[i] = int(bard)
        else:
            dia_input = st.text_input("Enter the diameter of all reinforcement bars with space(same order as above) : ")
            dia = list(map(int, dia_input.split()))

        for i in range(len(x_d)):
            cv2.circle(img, (int(100 + 2*x_d[i]),int(100 + 2*y_d[i])), int(dia[i]), (255, 0, 0), -1)

        #The image is resized
        dim = (int(b/2)+100,int(l/2)+100)
        resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)

        #display of the cross-section
        st.image(resized, caption='Cross-section')

        #Analysis of the cross section begins
        #the area of steel and concrete from each layer is calculated
        areac=[]
        areas=[]
        for i in range(100,100+l):
            c = 0
            s = 0
            for j in range(100,100+b):
                if img[i][j][0] == [0] and img[i][j][1] == [255] and img[i][j][2] == [0]:
                    c = c+1
                if img[i][j][0] == [255] and img[i][j][1] == [255] and img[i][j][2] == [255]:
                    c = c+1
                if img[i][j][0] == [255] and img[i][j][1] == [0] and img[i][j][2] == [0]:
                    s = s+1
            areac.append(c)
            areas.append(s)

        #defining of parameters
        ratio = []
        comp_len= []
        strain = []
        stress_s=[]
        stress_c=[]
        force = np.zeros([22])
        moment = np.zeros([22])
        mom_c = np.zeros([l])
        mom_s = np.zeros([l])
        force_c = np.zeros([l])
        force_s = np.zeros([l])

        #calculating the reinforcement ratio
        pt = math.fsum(areas)/(math.fsum(areas)+math.fsum(areac))

        #centroidal axis for the cross-section
        c_a = 0
        temp = 0
        for i in range(l):
            temp = (areac[i]*0.447*Fck+areas[i]*0.869*grade)*(i+1)
            c_a = c_a + temp
        C = (c_a)/(math.fsum(areas)*0.869*grade+math.fsum(areac)*0.447*Fck)

        #the each ratio is reffered to different position of neutral axis
        ratio = [40.0,20.0,5.0,2.0,1.5,1.4,1.3,1.2,1.1,1.05,1.0,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1]

        #analysing the section for each position of neutral axis
        for o in range(20):
            strain = np.zeros([l])
            stress_s=[]
            stress_c=[]
            if o < 11:
                for i in range(l):
                    strain[i]= abs((-0.002/(ratio[o]*l-(3/7)*l))*(i-ratio[o]*l))
            else:
                for i in range(l):
                    strain[i]= abs((-0.0035/(ratio[o]*l))*(i-ratio[o]*l))

            #generating stress strain profiles for different grades of steel
            if grade == 415:
                ydata = np.array([0,288.7,306.7,324.8,342.8,351.8,360.9,360.9,360.9,360.9])
                xdata = np.array([0,0.00144,0.00163,0.00192,0.00241,0.00276,0.00380,0.008,0.02,0.0320])
            elif grade == 500:
                ydata = np.array([0,347.8,369.6,391.3,413.0,423.9,434.8,434.8,434.8])
                xdata = np.array([0,0.00174,0.00195,0.00226,0.00277,0.00312,0.00417,0.005,0.04])
            elif grade == 250:
                ydata = np.array([0,217.5,217.5,217.5])
                xdata = np.array([0,0.001084,0.005,0.04])
            f_s = interp1d(xdata, ydata, kind='linear')
            for i in range(l):
                temp = f_s(strain[i])
                stress_s.append(temp)

            #generating the concrete stress strain curve
            n = 0.00
            fck = np.zeros([30])
            N = np.zeros([30])
            for i in range(21) :
                fck[i] = 0.447*Fck*(((2*n)/0.002)-(n/0.002)**2)
                N[i] = n
                n = n + 0.0001
            for i in range(21,30):
                fck[i]= 0.447*Fck
                N[i] = n
                n=n + 0.015
            f_c = interp1d(N,fck, kind='cubic')

            #extracting stress from the stress strain profile of concrete
            for i in range(l):
                temp = f_c(strain[i])
                stress_c.append(temp)

            #calculating the total force acting on the cross section(+ve for compression and -ve for tension)
            for i in range (l):
                if i < ratio[o]*l:
                    force_c[i] = stress_c[i]*areac[i]
                    force_s[i] = stress_s[i]*areas[i]
                else:
                    force_c[i] = 0
                    force_s[i] = -stress_s[i]*areas[i]
            force[o] = (math.fsum(force_c) + math.fsum(force_s))

            #calculating the total moment acting on the cross section(+ve for anti-clockwise and -ve for clockwise)
            for i in range (l):
                mom_c[i] = force_c[i]*(int(C)-i)
                mom_s[i] = force_s[i]*(int(C)-i)
            moment[o] = math.fsum(mom_c)+math.fsum(mom_s)

        #pure compression point and point with minimum eccentricity
        force[20] = int((0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        moment[20] = 0
        force[21] = int(0.9*(0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        emin = max(0.05*l0,20)
        moment[21] = force[21]*emin

        #Normalized forces and moments
        force = force/(4000)
        moment = moment/(4000000)

        #sorting them for plotting purpose
        sorted_force=np.sort(force[0:21])
        org_moment=np.zeros(21)
        for i in range(21):
            k=np.where(force==sorted_force[i])
            org_moment[i]=moment[k[0][0]]

        #interpolating to generate the curve
        int_cur = interp1d(sorted_force,np.array(org_moment), kind='cubic')

        #converting the image into gray scale for final representation
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        (thresh, cross_section) = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

        y_values = [force[21],force[21]]
        x_values = [0,int_cur(force[21])]

        #plotting our current interaction curve
        fig, ax = plt.subplots(dpi=1200)
        ax.plot(int_cur(sorted_force),sorted_force, label = ' program based')
        ax.plot(x_values,y_values,'g--', label = 'min. ecc. loading')
        ax.set_title("interaction diagram")
        ax.set_xlim(0)
        ax.set_ylim(0)
        ax.set_xlabel('$M_u(kNm)$')
        ax.set_ylabel('$P_u(kN)$')
        ax.grid(visible = True, color='r',which='major', ls = '-', lw = 0.4)
        ax.grid(visible =True, which='minor', color='r', linestyle='-', alpha=0.15)
        ax.minorticks_on()
        ax.legend(loc = 'upper right',fontsize = 'x-small')
        st.pyplot(fig)
        #Download
        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        st.download_button(
            label="Download plot as PNG",
            data=buf,
            file_name="Interaction_plot.png",
            mime="image/png"
        )

        #check points : whether if the user wants to test any test points whether they are safe or unsafe
        def Check_points():
            check_points = st.radio('do you want to have some check points?', ['Yes', 'No'])
            if check_points == 'Yes':
                P = st.text_input("Enter the force values with space(in kN) :")
                P = list(map(float, P.split()))
                M = st.text_input("Enter the moment values with space(in kNm) : ")
                M = list(map(float, M.split()))
                
                fig2, ax2 = plt.subplots(dpi=1200)
                ax2.plot(int_cur(sorted_force),sorted_force, label = ' program based')
                ax2.plot(x_values,y_values,'g--', label = 'min. ecc. loading')
                ax2.plot(M, P, 'bo',label = 'checks points')
                for i in range(len(P)):
                    ax2.text(M[i] , P[i]  , i+1, fontsize=12)
                ax2.grid(visible = True, color='r',which='major', ls = '-', lw = 0.4)
                ax2.grid(visible =True, which='minor', color='r', linestyle='-', alpha=0.15)
                ax2.minorticks_on()
                ax2.set_title('Safety check points')
                ax2.set_xlim(0)
                ax2.set_ylim(0)
                ax2.legend(loc = 'upper right',fontsize = 'x-small')
                ax2.set_xlabel('$M_u(kNm)$')
                ax2.set_ylabel('$P_u(kN)$')
                st.pyplot(fig2)
        
        Check_points()

    if t == 4:
        #instructions to the user
        st.subheader("Instructions for generating interaction diagram for general cross-section")
        st.write("1. The coordinates of the image should be defined such that the bending axis of the cross-section has to be horizontal")
        st.write("2. The coordinate system followed should be as per Quadrant 4 (only magnitudes)")
        st.write("3. The top most point should be in contact with X-axis")
        st.write("4. The left most point should be in contact with Y-axis")

        #dimensions and layout of the cross-section
        v = st.number_input("Enter the no. of vertices of the cross-section : ", min_value=3, step=1, value=4)
        b0 = st.number_input("Enter the width of section(mm) : ", min_value=1, step=1, value=300)
        b = b0*2
        l0 = st.number_input("Enter the length of the section(mm) : ", min_value=1, step=1, value=500)
        l = 2*l0
        
        ver_x = []
        ver_y = []
        for i in range(v):
            temp2 = st.number_input(f'enter the X_coordinate of vertex {i} (clockwise order): ', step=1, value=0)
            ver_x.append(temp2)
            temp1 = st.number_input(f'enter the Y_coordinate of vertex {i} (clockwise order): ', value=0.0)
            ver_y.append(temp1)

        #grade of steel
        grade = st.selectbox('enter the grade of steel : ', [250,415,500])
        #The grade of the concrete
        Fck = st.number_input('enter the grade of concrete :', min_value=0.1, value=20.0)

        # coordinates of the reinforcement bars
        x_d = st.text_input("Enter the X-coordinates of all reinforcement bars with space :")
        x_d = list(map(int, x_d.split()))
        y_d = st.text_input("Enter the Y-coordinates of all reinforcement bars with space(same order as above) : ")
        y_d = list(map(int, y_d.split()))
        dia = np.zeros([len(x_d)])
        pro = st.radio("are dia are equal:", ["Y", "N"])
        if pro == "Y":
            bard = st.number_input("dia of bars:", min_value=1, step=1, value=12)
            for i in range(len(x_d)):
                dia[i] = int(bard)
        else:
            dia_input = st.text_input("Enter the diameter of all reinforcement bars with space(same order as above) : ")
            dia = list(map(int, dia_input.split()))

        #clear cover of the cross section
        min_cover = max(dia/2) if len(dia) > 0 else 6
        cc0 = st.number_input('enter the effective cover of column in mm : ', min_value=float(min_cover), value=40.0)
        cc = 2*cc0

        #the outline of the cross-section
        img = np.zeros((l+200, b+200, 3), dtype = "uint8")
        for i in range(v-1):
            cv2.line(img, (int(100+2*ver_x[i]),int(100+2*ver_y[i])), (int(100+2*ver_x[i+1]),int(100+2*ver_y[i+1])), (255, 255, 255), 1)
        cv2.line(img, (int(100+2*ver_x[v-1]),int(100+2*ver_y[v-1])), (int(100+2*ver_x[0]),int(100+2*ver_y[0])), (255, 255, 255), 1)

        #concrete part in the cross-section
        for i in range(l+199):
            count = 0
            for j in range(b+199):
                if img[i][j][0] == [255] and img[i][j][1] == [255] and img[i][j][2] == [255] and img[i][j+1][0] == [0] and img[i][j+1][1] == [0] and img[i][j+1][2] == [0]:
                    count = count + 1
                if count  == 1 or count == 3 or count == 5 or count == 7 or count == 9 :
                    img[i][j][0] = 0
                    img[i][j][1] = 255
                    img[i][j][2] = 0
            if count  == 1:
                for j in range (b+200):
                    if img[i][j][0] == [0] and img[i][j][1] == [255] and img[i][j][2] == [0]:
                        img[i][j][0] = 0
                        img[i][j][1] = 0
                        img[i][j][2] = 0

        #reinforcements in the cross-section
        for i in range(len(x_d)):
            cv2.circle(img, (int(100+2*x_d[i]),int(100+2*y_d[i])), int(dia[i]), (255, 0, 0), -1)

        #the image is resized
        dim = (int(b/2)+100,int(l/2)+100)
        resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)

        #display of the cross-section
        st.image(resized, caption='Cross-section')

        #Analysis of the cross section begins
        #the area of steel and concrete from each layer is calculated
        areac=[]
        areas=[]
        for i in range(100,100+l):
            c = 0
            s = 0
            for j in range(100,100+b):
                if img[i][j][0] == [0] and img[i][j][1] == [255] and img[i][j][2] == [0]:
                    c = c+1
                elif img[i][j][0] == [255] and img[i][j][1] == [255] and img[i][j][2] == [255]:
                    c = c+1
                elif img[i][j][0] == [255] and img[i][j][1] == [0] and img[i][j][2] == [0]:
                    s = s+1
            areac.append(c)
            areas.append(s)

        #defining the parameters
        ratio = []
        comp_len= []
        strain = []
        stress_s=[]
        stress_c=[]
        force = np.zeros([22])
        moment = np.zeros([22])
        mom_c = np.zeros([l])
        mom_s = np.zeros([l])
        force_c = np.zeros([l])
        force_s = np.zeros([l])

        #calculating the reinforcement ratio
        pt = math.fsum(areas)/(math.fsum(areas)+math.fsum(areac))

        #centroidal axis for the cross-section
        c_a = 0
        temp = 0
        for i in range(l):
            temp = (areac[i]*0.447*Fck+areas[i]*0.87*grade)*(i+1)
            c_a = c_a + temp
        C = (c_a)/(math.fsum(areas)*0.87*grade+math.fsum(areac)*0.447*Fck)

        #the each ratio is reffered to different position of neutral axis
        ratio = [40.0,20.0,5.0,2.0,1.5,1.4,1.3,1.2,1.1,1.05,1.0,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1]

        #analysing the section for each position of neutral axis
        for o in range(20):
            strain = np.zeros([l])
            stress_s=[]
            stress_c=[]
            if o < 11:
                for i in range(l):
                    strain[i]= abs((-0.002/(ratio[o]*l-(3/7)*l))*(i-ratio[o]*l))
            else:
                for i in range(l):
                    strain[i]= abs((-0.0035/(ratio[o]*l))*(i-ratio[o]*l))

            #generating stress strain profiles for different grades of steel
            if grade == 415:
                ydata = np.array([0,288.7,306.7,324.8,342.8,351.8,360.9,360.9,360.9,360.9])
                xdata = np.array([0,0.00144,0.00163,0.00192,0.00241,0.00276,0.00380,0.008,0.02,0.0320])
            elif grade == 500:
                ydata = np.array([0,347.8,369.6,391.3,413.0,423.9,434.8,434.8,434.8])
                xdata = np.array([0,0.00174,0.00195,0.00226,0.00277,0.00312,0.00417,0.005,0.04])
            elif grade == 250:
                ydata = np.array([0,217.5,217.5,217.5])
                xdata = np.array([0,0.001084,0.005,0.04])
            f_s = interp1d(xdata, ydata, kind='linear')
            for i in range(l):
                temp = f_s(strain[i])
                stress_s.append(temp)

            #generating the concrete stress strain curve
            n = 0.00
            fck = np.zeros([30])
            N = np.zeros([30])
            for i in range(21) :
                fck[i] = 0.447*Fck*(((2*n)/0.002)-(n/0.002)**2)
                N[i] = n
                n = n + 0.0001
            for i in range(21,30):
                fck[i]= 0.447*Fck
                N[i] = n
                n=n + 0.015
            f_c = interp1d(N,fck, kind='cubic')

            #extracting stress from the stress strain profile of concrete
            for i in range(l):
                temp = f_c(strain[i])
                stress_c.append(temp)

            #calculating the total force acting on the cross section(+ve for compression and -ve for tension)
            for i in range (l):
                if i < ratio[o]*l:
                    force_c[i] = stress_c[i]*areac[i]
                    force_s[i] = stress_s[i]*areas[i]
                else:
                    force_c[i] = 0
                    force_s[i] = -stress_s[i]*areas[i]
            force[o] = (math.fsum(force_c) + math.fsum(force_s))

            #calculating the total moment acting on the cross section(+ve for anti-clockwise and -ve for clockwise)
            for i in range (l):
                mom_c[i] = force_c[i]*(int(C)-i)
                mom_s[i] = force_s[i]*(int(C)-i)
            moment[o] = math.fsum(mom_c)+math.fsum(mom_s)

        #pure compression point and point with minimum eccentricity
        force[20] = int((0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        moment[20] = 0
        force[21] = int(0.9*(0.447*Fck*(math.fsum(areac)) + f_s(0.002)*(math.fsum(areas))))
        emin = max(0.05*l,20)
        moment[21] = force[21]*emin

        force = force/(4000)
        moment = moment/(4000000)

        #sorting them for plotting purpose
        sorted_force=np.sort(force[0:21])
        org_moment=np.zeros(21)
        for i in range(21):
            k=np.where(force==sorted_force[i])
            org_moment[i]=moment[k[0][0]]

        #interpolating to generate the curve
        int_cur = interp1d(sorted_force,np.array(org_moment), kind='cubic')

        #minimun eccentric line
        y_values = [force[21],force[21]]
        x_values = [0,int_cur(force[21])]

        #plotting our current interaction curve
        fig, ax = plt.subplots(dpi=1200)
        ax.plot(int_cur(sorted_force),sorted_force, label = 'program based')
        ax.plot(x_values,y_values,'g--', label = 'min. ecc. loading')
        ax.set_xlim(0)
        ax.set_ylim(0)
        ax.set_title('interaction diagram')
        ax.set_xlabel('$M_u (kN.m)$')
        ax.set_ylabel('$P_u (kN)$')
        ax.grid(visible = True, color='r',which='major', ls = '-', lw = 0.4)
        ax.grid(visible =True, which='minor', color='r', linestyle='-', alpha=0.15)
        ax.minorticks_on()
        ax.legend(loc = 'upper right',fontsize = 'x-small')
        st.pyplot(fig)
        #Download
        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        st.download_button(
            label="Download plot as PNG",
            data=buf,
            file_name="Interaction_plot.png",
            mime="image/png"
        )
        #check points : whether if the user wants to test any test points whether they are safe or unsafe
        def Check_points():
            check_points = st.radio('do you want to have some check points?', ['Yes', 'No'])
            if check_points == 'Yes':
                P = st.text_input("Enter the force values with space(in kN) :")
                P = list(map(float, P.split()))
                M = st.text_input("Enter the moment values with space(in kNm) : ")
                M = list(map(float, M.split()))
                
                fig2, ax2 = plt.subplots(dpi=1200)
                ax2.plot(int_cur(sorted_force),sorted_force, label = 'program based')
                ax2.plot(x_values,y_values,'g--', label = 'min. ecc. loading')
                ax2.plot(M, P, 'bo',label = 'checks points')
                for i in range(len(P)):
                    ax2.text(M[i], P[i], i+1, fontsize=12)
                ax2.grid(visible = True, color='r',which='major', ls = '-', lw = 0.4)
                ax2.grid(visible =True, which='minor', color='r', linestyle='-', alpha=0.15)
                ax2.minorticks_on()
                ax2.set_title('Safety check points')
                ax2.set_xlim(0)
                ax2.set_ylim(0)
                ax2.legend(loc = 'upper right',fontsize = 'x-small')
                ax2.set_xlabel('$M_u (kN.m)$')
                ax2.set_ylabel('$P_u (kN)$')
                st.pyplot(fig2)
        Check_points()

        end = time.time()
        st.write(f"Runtime of the program is {end - start}")

if __name__=="__main__":
    plotGenerator()
